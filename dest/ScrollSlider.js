(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"), require("jquery.easing"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery", "jquery.easing"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jquery"), require("jquery.easing")) : factory(root["jquery"], root["jquery.easing"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_jquery_easing__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ScrollSlider.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ScrollSlider.ts":
/*!*****************************!*\
  !*** ./src/ScrollSlider.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ScrollSlider; });\n/* harmony import */ var _SlideBars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SlideBars */ \"./src/SlideBars.ts\");\n/* Scroll slider\n * @Author: bai\n * @Date: 2019-12-04 17:24:22\n * @Last Modified by: bai\n * @Last Modified time: 2019-12-17 12:02:32\n */\n // import './ScrollSlider.css';\n\nclass ScrollSlider extends _SlideBars__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor($elm, options = {}, callbackMaps = {}) {\n    var defaultOptions = {\n      horizontal: 1,\n      startAt: 1,\n      smart: true,\n      activateOn: 'click',\n      itemNav: \"basic\",\n      dragContent: 1,\n      scrollBy: 1,\n      // releaseSwing: 1,\n      speed: 300,\n      // elasticBounds: 1,\n      easing: 'easeOutExpo',\n      // mouseDragging: 1,\n      touchDragging: 1,\n      clickButton: '.button' // easing: \"easeOutBack\", //\n      //     prev: prevButton,\n      //     next: nextButton,\n\n    };\n    super($elm, Object.assign(defaultOptions, options), callbackMaps);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/ScrollSlider.ts?");

/***/ }),

/***/ "./src/SlideBars.ts":
/*!**************************!*\
  !*** ./src/SlideBars.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SlideBars; });\n/* slide bars, Be based on Sly see: https://github.com/darsain/sly\n * @Author: bai\n * @Date: 2019-12-04 13:52:17\n * @Last Modified by: bai\n * @Last Modified time: 2019-12-17 11:52:05\n */\nlet $ = __webpack_require__(/*! jquery */ \"jquery\");\n\nlet easing = __webpack_require__(/*! jquery.easing */ \"jquery.easing\");\n\nclass SlideBars {\n  constructor(frame, options, callbackMap) {\n    // Local WindowAnimationTiming interface\n    // static cAF:Function;\n    // static rAF:Function;\n    this.pluginName = 'slideBars';\n    this.className = 'SlideBars';\n    this.namespace = 'slideBars'; // Math shorthands\n\n    this.abs = Math.abs;\n    this.sqrt = Math.sqrt;\n    this.pow = Math.pow;\n    this.round = Math.round;\n    this.max = Math.max;\n    this.min = Math.min;\n    window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;\n    window.requestAnimationFrame = window.requestAnimationFrame;\n    this.$doc = $(document);\n    this.dragInitEvents = 'touchstart.' + this.namespace + ' mousedown.' + this.namespace;\n    this.dragMouseEvents = 'mousemove.' + this.namespace + ' mouseup.' + this.namespace;\n    this.dragTouchEvents = 'touchmove.' + this.namespace + ' touchend.' + this.namespace;\n    this.wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel.' : 'mousewheel.') + this.namespace;\n    this.clickEvent = 'click.' + this.namespace;\n    this.mouseDownEvent = 'mousedown.' + this.namespace;\n    this.interactiveElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'];\n    this.tmpArray = []; // Math shorthands\n\n    this.abs = Math.abs;\n    this.sqrt = Math.sqrt;\n    this.pow = Math.pow;\n    this.round = Math.round;\n    this.max = Math.max;\n    this.min = Math.min; // Keep track of last fired global wheel event\n\n    this.lastGlobalWheel = 0;\n    this.$doc.on(this.wheelEvent, event => {\n      let sly = event.originalEvent[this.namespace];\n      let time = +new Date(); // Update last global wheel time, but only when event didn't originate\n      // in Sly frame, or the origin was less than scrollHijack time ago\n\n      if (!sly || sly.options.scrollHijack < time - this.lastGlobalWheel) this.lastGlobalWheel = time;\n    });\n    this.callbackMap = callbackMap; //Sly ------------------------------------------------------------------------\n    // if (!(this instanceof SlideBars)) return new SlideBars(frame, options, callbackMap);\n    // Default options\n\n    this.defaults = {\n      slidee: null,\n      horizontal: false,\n      // Item based navigation\n      itemNav: null,\n      itemSelector: null,\n      smart: false,\n      activateOn: null,\n      activateMiddle: false,\n      // Scrolling\n      scrollSource: null,\n      scrollBy: 0,\n      scrollHijack: 300,\n      scrollTrap: false,\n      // Dragging\n      dragSource: null,\n      mouseDragging: false,\n      touchDragging: false,\n      releaseSwing: false,\n      swingSpeed: 0.2,\n      elasticBounds: false,\n      dragThreshold: 3,\n      interactive: null,\n      // Scrollbar\n      scrollBar: null,\n      dragHandle: false,\n      dynamicHandle: false,\n      minHandleSize: 50,\n      clickBar: false,\n      syncSpeed: 0.5,\n      // Pagesbar\n      pagesBar: null,\n      activatePageOn: null,\n      pageBuilder: // Page item generator.\n      function (index) {\n        return '<li>' + (index + 1) + '</li>';\n      },\n      // Navigation buttons\n      forward: null,\n      backward: null,\n      prev: null,\n      next: null,\n      prevPage: null,\n      nextPage: null,\n      // Automated cycling\n      cycleBy: null,\n      cycleInterval: 5000,\n      pauseOnHover: false,\n      startPaused: false,\n      // Mixed options\n      moveBy: 300,\n      speed: 0,\n      easing: 'swing',\n      startAt: null,\n      keyboardNavBy: null,\n      // Classes\n      draggedClass: 'dragged',\n      activeClass: 'active',\n      disabledClass: 'disabled' // Class for disabled navigation elements.\n\n    }; // Extend options\n\n    this.o = $.extend({}, this.defaults, options);\n\n    if (frame instanceof HTMLElement) {\n      if (frame.clientWidth == 0) {\n        this.mutationObserver(frame, () => {\n          setTimeout(() => this.create(frame), 100);\n        });\n      } else {\n        setTimeout(() => this.create(frame), 100);\n      }\n    } else {\n      throw new Error('Must HTMLElement type !');\n    }\n  }\n\n  create(frame) {\n    // Private variables\n    this.parallax = this.isNumber(frame); // Frame\n\n    this.$frame = $(frame);\n    this.$slidee = this.o.slidee ? $(this.o.slidee).eq(0) : this.$frame.children().eq(0);\n    this.frameSize = 0;\n    this.slideeSize = 0;\n    this.pos = {\n      start: 0,\n      center: 0,\n      end: 0,\n      cur: 0,\n      dest: 0\n    }; // Scrollbar\n\n    this.$sb = $(this.o.scrollBar).eq(0);\n    this.$handle = this.$sb.children().eq(0);\n    this.sbSize = 0;\n    this.handleSize = 0;\n    this.hPos = {\n      start: 0,\n      end: 0,\n      cur: 0\n    }; // Pagesbar\n\n    this.$pb = $(this.o.pagesBar);\n    this.$pages = 0;\n    this.pages = []; // Items\n\n    this.$items = 0;\n    this.items = [];\n    this.rel = {\n      firstItem: 0,\n      lastItem: 0,\n      centerItem: 0,\n      activeItem: null,\n      activePage: 0\n    }; // Styles\n\n    this.frameStyles = new StyleRestorer(this.$frame[0]);\n    this.slideeStyles = new StyleRestorer(this.$slidee[0]);\n    this.sbStyles = new StyleRestorer(this.$sb[0]);\n    this.handleStyles = new StyleRestorer(this.$handle[0]); // Navigation type booleans\n\n    this.basicNav = this.o.itemNav === 'basic';\n    this.forceCenteredNav = this.o.itemNav === 'forceCentered';\n    this.centeredNav = this.o.itemNav === 'centered' || this.forceCenteredNav;\n    this.itemNav = !this.parallax && (this.basicNav || this.centeredNav || this.forceCenteredNav); // Miscellaneous\n\n    this.$scrollSource = this.o.scrollSource ? $(this.o.scrollSource) : this.$frame;\n    this.$dragSource = this.o.dragSource ? $(this.o.dragSource) : this.$frame;\n    this.$forwardButton = $(this.o.forward);\n    this.$backwardButton = $(this.o.backward);\n    this.$prevButton = $(this.o.prev);\n    this.$nextButton = $(this.o.next);\n    this.$prevPageButton = $(this.o.prevPage);\n    this.$nextPageButton = $(this.o.nextPage);\n    this.callbacks = {};\n    this.last = {};\n    this.animation = {};\n    this.move = {};\n    this.dragging = {\n      released: 1,\n      init: undefined\n    };\n    this.scrolling = {\n      last: 0,\n      delta: 0,\n      resetTime: 200\n    };\n    this.renderID = 0;\n    this.historyID = 0;\n    this.cycleID = 0;\n    this.continuousID = 0;\n    this.i = 0;\n    this.l = 0; // Normalizing frame\n\n    if (!this.parallax) {\n      frame = this.$frame[0];\n    } // Expose properties\n\n\n    this.initialized = 0;\n    this.frame = frame;\n    this.slidee = this.$slidee[0];\n    this.pos = this.pos;\n    this.rel = this.rel; // this.items = this.items;\n\n    this.pages = this.pages;\n    this.isPaused = 0;\n    this.options = this.o; // this.dragging = this.dragging;\n\n    this.polyfill();\n    this.featureDetects();\n    this.init();\n  }\n  /**\n   * 创建jquery代理\n   */\n\n\n  createJqueryProxy() {\n    // jQuery proxy\n    $.fn[this.pluginName] = function (options, callbackMap) {\n      var method, methodArgs; // Attributes logic\n\n      if (!$.isPlainObject(options)) {\n        if (SlideBars.type(options) === 'string' || options === false) {\n          method = options === false ? 'destroy' : options;\n          methodArgs = Array.prototype.slice.call(arguments, 1);\n        }\n\n        options = {};\n      } // Apply to all elements\n\n\n      return this.each((i, element) => {\n        // Call with prevention against multiple instantiations\n        var plugin = SlideBars.getInstance(element, this.namespace);\n\n        if (!plugin && !method) {\n          // Create a new object if it doesn't exist yet\n          plugin = new SlideBars(element, options, callbackMap).init();\n        } else if (plugin && method) {\n          // Call method\n          if (plugin[method]) {\n            plugin[method].apply(plugin, methodArgs);\n          }\n        }\n      });\n    };\n  } // Local WindowAnimationTiming interface polyfill\n\n\n  polyfill() {\n    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || fallback;\n    /**\n    * Fallback implementation.\n    */\n\n    var prev = new Date().getTime();\n\n    function fallback(fn) {\n      var curr = new Date().getTime();\n      var ms = Math.max(0, 16 - (curr - prev));\n      var req = setTimeout(fn, ms);\n      prev = curr;\n      return req;\n    }\n    /**\n    * Cancel.\n    */\n\n\n    var cancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;\n\n    window.cancelAnimationFrame = id => {\n      cancel.call(window, id);\n    };\n  } //Feature detects\n\n\n  featureDetects() {\n    var prefixes = ['', 'Webkit', 'Moz', 'ms', 'O'];\n    var el = document.createElement('div');\n\n    function testProp(prop) {\n      for (var p = 0, pl = prefixes.length; p < pl; p++) {\n        var prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;\n\n        if (el.style[prefixedProp] != null) {\n          return prefixedProp;\n        }\n      }\n    } // Global support indicators\n\n\n    this.transform = testProp('transform');\n    this.gpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : ''; // Expose class globally\n\n    window[this.className] = SlideBars;\n  }\n  /**\n   * dom element observer\n   * @param element\n   * @param ready\n   */\n\n\n  mutationObserver(element, ready) {\n    var observer = new MutationObserver((mutationsList, mutationObserver) => {\n      for (var mutation of mutationsList) {\n        if (mutation.target.clientWidth > 0) {\n          observer.disconnect();\n          mutationObserver.disconnect();\n          ready();\n          break;\n        }\n      }\n    });\n\n    if (element) {\n      observer.observe(element, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n  /**\n   * Loading function.\n   *\n   * Populate arrays, set sizes, bind events, ...\n   *\n   * @param {Boolean} [isInit] Whether load is called from within self.init().\n   * @return {Void}\n   */\n\n\n  load(isInit = false) {\n    // Local variables\n    var lastItemsCount = 0;\n    var lastPagesCount = this.pages.length; // Save old position\n\n    this.pos.old = $.extend({}, this.pos); // Reset global variables\n\n    this.frameSize = this.parallax ? 0 : this.$frame[this.o.horizontal ? 'width' : 'height']();\n    this.sbSize = this.$sb[this.o.horizontal ? 'width' : 'height']();\n    this.slideeSize = this.parallax ? this.frame : this.$slidee[this.o.horizontal ? 'outerWidth' : 'outerHeight']();\n    this.pages.length = 0; // Set position limits & relatives\n\n    this.pos.start = 0;\n    this.pos.end = this.max(this.slideeSize - this.frameSize, 0); // Sizes & offsets for item based navigations\n\n    if (this.itemNav) {\n      // Save the number of current items\n      lastItemsCount = this.items.length; // Reset itemNav related variables\n\n      this.$items = this.$slidee.children(this.o.itemSelector);\n      this.items.length = 0; // Needed variables\n\n      let paddingStart = this.getPx(this.$slidee, this.o.horizontal ? 'paddingLeft' : 'paddingTop');\n      let paddingEnd = this.getPx(this.$slidee, this.o.horizontal ? 'paddingRight' : 'paddingBottom');\n      let borderBox = $(this.$items).css('boxSizing') === 'border-box';\n      let areFloated = this.$items.css('float') !== 'none';\n      let ignoredMargin = 0;\n      let lastItemIndex = this.$items.length - 1;\n      let lastItem; // Reset slideeSize\n\n      this.slideeSize = 0; // Iterate through items\n\n      this.$items.each((i, element) => {\n        // Item\n        let $item = $(element);\n        let rect = element.getBoundingClientRect();\n        let itemSize = this.round(this.o.horizontal ? rect.width || rect.right - rect.left : rect.height || rect.bottom - rect.top);\n        let itemMarginStart = this.getPx($item, this.o.horizontal ? 'marginLeft' : 'marginTop');\n        let itemMarginEnd = this.getPx($item, this.o.horizontal ? 'marginRight' : 'marginBottom');\n        let itemSizeFull = itemSize + itemMarginStart + itemMarginEnd;\n        let singleSpaced = !itemMarginStart || !itemMarginEnd;\n        let item = {};\n        item.el = element;\n        item.size = singleSpaced ? itemSize : itemSizeFull;\n        item.half = item.size / 2;\n        item.start = this.slideeSize + (singleSpaced ? itemMarginStart : 0);\n        item.center = item.start - this.round(this.frameSize / 2 - item.size / 2);\n        item.end = item.start - this.frameSize + item.size; // Account for slidee padding\n\n        if (!i) {\n          this.slideeSize += paddingStart;\n        } // Increment slidee size for size of the active element\n\n\n        this.slideeSize += itemSizeFull; // Try to account for vertical margin collapsing in vertical mode\n        // It's not bulletproof, but should work in 99% of cases\n\n        if (!this.o.horizontal && !areFloated) {\n          // Subtract smaller margin, but only when top margin is not 0, and this is not the first element\n          if (itemMarginEnd && itemMarginStart && i > 0) {\n            this.slideeSize -= this.min(itemMarginStart, itemMarginEnd);\n          }\n        } // Things to be done on last item\n\n\n        if (i === lastItemIndex) {\n          item.end += paddingEnd;\n          this.slideeSize += paddingEnd;\n          ignoredMargin = singleSpaced ? itemMarginEnd : 0;\n        } // Add item object to items array\n\n\n        this.items.push(item);\n        lastItem = item;\n      }); // Resize SLIDEE to fit all items\n\n      this.$slidee[0].style[this.o.horizontal ? 'width' : 'height'] = (borderBox ? this.slideeSize : this.slideeSize - paddingStart - paddingEnd) + 'px'; // Adjust internal SLIDEE size for last margin\n\n      this.slideeSize -= ignoredMargin; // Set limits\n\n      if (this.items.length) {\n        this.pos.start = this.items[0][this.forceCenteredNav ? 'center' : 'start'];\n        this.pos.end = this.forceCenteredNav ? lastItem.center : this.frameSize < this.slideeSize ? lastItem.end : this.pos.start;\n      } else {\n        this.pos.start = this.pos.end = 0;\n      }\n    } // Calculate SLIDEE center position\n\n\n    this.pos.center = this.round(this.pos.end / 2 + this.pos.start / 2); // Update relative positions\n\n    this.updateRelatives(); // Scrollbar\n\n    if (this.$handle.length && this.sbSize > 0) {\n      // Stretch scrollbar handle to represent the visible area\n      if (this.o.dynamicHandle) {\n        this.handleSize = this.pos.start === this.pos.end ? this.sbSize : this.round(this.sbSize * this.frameSize / this.slideeSize);\n        this.handleSize = this.within(this.handleSize, this.o.minHandleSize, this.sbSize);\n        this.$handle[0].style[this.o.horizontal ? 'width' : 'height'] = this.handleSize + 'px';\n      } else {\n        this.handleSize = this.$handle[this.o.horizontal ? 'outerWidth' : 'outerHeight']();\n      }\n\n      this.hPos.end = this.sbSize - this.handleSize;\n\n      if (!this.renderID) {\n        this.syncScrollbar();\n      }\n    } // Pages\n\n\n    if (!this.parallax && this.frameSize > 0) {\n      var tempPagePos = this.pos.start;\n      var pagesHtml = ''; // Populate pages array\n\n      if (this.itemNav) {\n        $.each(this.items, (i, item) => {\n          if (this.forceCenteredNav) {\n            this.pages.push(item.center);\n          } else if (item.start + item.size > tempPagePos && tempPagePos <= this.pos.end) {\n            tempPagePos = item.start;\n            this.pages.push(tempPagePos);\n            tempPagePos += this.frameSize;\n\n            if (tempPagePos > this.pos.end && tempPagePos < this.pos.end + this.frameSize) {\n              this.pages.push(this.pos.end);\n            }\n          }\n        });\n      } else {\n        while (tempPagePos - this.frameSize < this.pos.end) {\n          this.pages.push(tempPagePos);\n          tempPagePos += this.frameSize;\n        }\n      } // Pages bar\n\n\n      if (this.$pb[0] && lastPagesCount !== this.pages.length) {\n        for (var i = 0; i < this.pages.length; i++) {\n          pagesHtml += this.o.pageBuilder.call(this, i);\n        }\n\n        this.$pages = this.$pb.html(pagesHtml).children();\n        this.$pages.eq(this.rel.activePage).addClass(this.o.activeClass);\n      }\n    } // Extend relative variables object with some useful info\n\n\n    this.rel.slideeSize = this.slideeSize;\n    this.rel.frameSize = this.frameSize;\n    this.rel.sbSize = this.sbSize;\n    this.rel.handleSize = this.handleSize; // Activate requested position\n\n    if (this.itemNav) {\n      if (isInit && this.o.startAt != null) {\n        this._activate(this.o.startAt);\n\n        if (this.centeredNav) this.toCenter(this.o.startAt);else this.toStart(this.o.startAt);\n      } // Fix possible overflowing\n\n\n      var activeItem = this.items[this.rel.activeItem];\n\n      this._slideTo(this.centeredNav && activeItem ? activeItem.center : this.within(this.pos.dest, this.pos.start, this.pos.end));\n    } else {\n      if (isInit) {\n        if (this.o.startAt != null) this.slideTo(this.o.startAt, true); //1\n      } else {\n        // Fix possible overflowing\n        this._slideTo(this.within(this.pos.dest, this.pos.start, this.pos.end));\n      }\n    } // Trigger load event\n\n\n    this.trigger('load');\n  }\n\n  reload() {\n    this.load();\n  }\n\n  /**\n   * Animate to a position.\n   *\n   * @param {Int}  newPos    New position.\n   * @param {Bool} immediate Reposition immediately without an animation.\n   * @param {Bool} dontAlign Do not align items, use the raw position passed in first argument.\n   *\n   * @return {Void}\n   */\n  _slideTo(newPos, immediate = false, dontAlign = false) {\n    // Align items\n    if (this.itemNav && this.dragging.released && !dontAlign) {\n      var tempRel = this.getRelatives(newPos);\n      var isNotBordering = newPos > this.pos.start && newPos < this.pos.end;\n\n      if (this.centeredNav) {\n        if (isNotBordering) {\n          newPos = this.items[tempRel.centerItem].center;\n        }\n\n        if (this.forceCenteredNav && this.o.activateMiddle) {\n          this._activate(tempRel.centerItem);\n        }\n      } else if (isNotBordering) {\n        newPos = this.items[tempRel.firstItem].start;\n      }\n    } // Handle overflowing position limits\n\n\n    if (this.dragging.init && this.dragging.slidee && this.o.elasticBounds) {\n      if (newPos > this.pos.end) {\n        newPos = this.pos.end + (newPos - this.pos.end) / 6;\n      } else if (newPos < this.pos.start) {\n        newPos = this.pos.start + (newPos - this.pos.start) / 6;\n      }\n    } else {\n      newPos = this.within(newPos, this.pos.start, this.pos.end);\n    } // Update the animation object\n\n\n    this.animation.start = +new Date();\n    this.animation.time = 0;\n    this.animation.from = this.pos.cur;\n    this.animation.to = newPos;\n    this.animation.delta = newPos - this.pos.cur;\n    this.animation.tweesing = this.dragging.tweese || this.dragging.init && !this.dragging.slidee;\n    this.animation.immediate = !this.animation.tweesing && (immediate || this.dragging.init && this.dragging.slidee || !this.o.speed); // Reset dragging tweesing request\n\n    this.dragging.tweese = 0; // Start animation rendering\n\n    if (newPos !== this.pos.dest) {\n      this.pos.dest = newPos;\n      this.trigger('change');\n\n      if (!this.renderID) {\n        this.render();\n      }\n    } // Reset next cycle timeout\n\n\n    this.resetCycle(); // Synchronize states\n\n    this.updateRelatives();\n    this.updateButtonsState();\n    this.syncPagesbar();\n  }\n  /**\n   * Render animation frame.\n   *\n   * @return {Void}\n   */\n\n\n  render() {\n    if (!this.initialized) {\n      return;\n    } // If first render call, wait for next animationFrame\n\n\n    if (!this.renderID) {\n      this.renderID = requestAnimationFrame(this.render.bind(this));\n\n      if (this.dragging.released) {\n        this.trigger('moveStart');\n      }\n\n      return;\n    } // If immediate repositioning is requested, don't animate.\n\n\n    if (this.animation.immediate) {\n      this.pos.cur = this.animation.to;\n    } // Use tweesing for animations without known end point\n    else if (this.animation.tweesing) {\n        this.animation.tweeseDelta = this.animation.to - this.pos.cur; // Fuck Zeno's paradox\n\n        if (this.abs(this.animation.tweeseDelta) < 0.1) {\n          this.pos.cur = this.animation.to;\n        } else {\n          this.pos.cur += this.animation.tweeseDelta * (this.dragging.released ? this.o.swingSpeed : this.o.syncSpeed);\n        }\n      } // Use tweening for basic animations with known end point\n      else {\n          this.animation.time = this.min(+new Date() - this.animation.start, this.o.speed);\n          this.pos.cur = this.animation.from + this.animation.delta * $.easing[this.o.easing](this.animation.time / this.o.speed, this.animation.time, 0, 1, this.o.speed);\n        } // If there is nothing more to render break the rendering loop, otherwise request new animation frame.\n\n\n    if (this.animation.to === this.pos.cur) {\n      this.pos.cur = this.animation.to;\n      this.dragging.tweese = this.renderID = 0;\n    } else {\n      this.renderID = requestAnimationFrame(this.render.bind(this));\n    }\n\n    this.trigger('move'); // Update SLIDEE position\n\n    if (!this.parallax) {\n      if (this.transform) {\n        this.$slidee[0].style[this.transform] = this.gpuAcceleration + (this.o.horizontal ? 'translateX' : 'translateY') + '(' + -this.pos.cur + 'px)';\n      } else {\n        this.$slidee[0].style[this.o.horizontal ? 'left' : 'top'] = -this.round(this.pos.cur) + 'px';\n      }\n    } // When animation reached the end, and dragging is not active, trigger moveEnd\n\n\n    if (!this.renderID && this.dragging.released) {\n      this.trigger('moveEnd');\n    }\n\n    this.syncScrollbar();\n  }\n  /**\n   * Synchronizes scrollbar with the SLIDEE.\n   *\n   * @return {Void}\n   */\n\n\n  syncScrollbar() {\n    if (this.$handle.length) {\n      this.hPos.cur = this.pos.start === this.pos.end ? 0 : ((this.dragging.init && !this.dragging.slidee ? this.pos.dest : this.pos.cur) - this.pos.start) / (this.pos.end - this.pos.start) * this.hPos.end;\n      this.hPos.cur = this.within(this.round(this.hPos.cur), this.hPos.start, this.hPos.end);\n\n      if (this.last.hPos !== this.hPos.cur) {\n        this.last.hPos = this.hPos.cur;\n\n        if (this.transform) {\n          this.$handle[0].style[this.transform] = this.gpuAcceleration + (this.o.horizontal ? 'translateX' : 'translateY') + '(' + this.hPos.cur + 'px)';\n        } else {\n          this.$handle[0].style[this.o.horizontal ? 'left' : 'top'] = this.hPos.cur + 'px';\n        }\n      }\n    }\n  }\n  /**\n   * Synchronizes pagesbar with SLIDEE.\n   *\n   * @return {Void}\n   */\n\n\n  syncPagesbar() {\n    if (this.$pages[0] && this.last.page !== this.rel.activePage) {\n      this.last.page = this.rel.activePage;\n      this.$pages.removeClass(this.o.activeClass).eq(this.rel.activePage).addClass(this.o.activeClass);\n      this.trigger('activePage', this.last.page);\n    }\n  }\n  /**\n   * Returns the position object.\n   *\n   * @param {Mixed} item\n   *\n   * @return {Object}\n   */\n\n\n  getPos(item) {\n    if (this.itemNav) {\n      let index = this.getIndex(item);\n      return index !== -1 ? this.items[index] : false;\n    } else {\n      var $item = this.$slidee.find(item).eq(0);\n\n      if ($item[0]) {\n        var offset = this.o.horizontal ? $item.offset().left - this.$slidee.offset().left : $item.offset().top - this.$slidee.offset().top;\n        var size = $item[this.o.horizontal ? 'outerWidth' : 'outerHeight']();\n        return {\n          start: offset,\n          center: offset - this.frameSize / 2 + size / 2,\n          end: offset - this.frameSize + size,\n          size: size\n        };\n      } else {\n        return false;\n      }\n    }\n  }\n  /**\n   * Continuous move in a specified direction.\n   *\n   * @param  {Bool} forward True for forward movement, otherwise it'll go backwards.\n   * @param  {Int}  speed   Movement speed in pixels per frame. Overrides options.moveBy value.\n   *\n   * @return {Void}\n   */\n\n\n  moveBy(speed) {\n    this.move.speed = speed; // If already initiated, or there is nowhere to move, abort\n\n    if (this.dragging.init || !this.move.speed || this.pos.cur === (this.move.speed > 0 ? this.pos.end : this.pos.start)) {\n      return;\n    } // Initiate move object\n\n\n    this.move.lastTime = +new Date();\n    this.move.startPos = this.pos.cur; // Set dragging as initiated\n\n    this.continuousInit('button');\n    this.dragging.init = 1; // Start movement\n\n    this.trigger('moveStart');\n    cancelAnimationFrame(this.continuousID.bind(this));\n    this.moveLoop();\n  }\n  /**\n   * Continuous movement loop.\n   *\n   * @return {Void}\n   */\n\n\n  moveLoop() {\n    // If there is nowhere to move anymore, stop\n    if (!this.move.speed || this.pos.cur === (this.move.speed > 0 ? this.pos.end : this.pos.start)) {\n      this.stop();\n    } // Request new move loop if it hasn't been stopped\n\n\n    this.continuousID = this.dragging.init ? requestAnimationFrame(this.moveLoop.bind(this)) : 0; // Update move object\n\n    this.move.now = +new Date();\n    this.move.pos = this.pos.cur + (this.move.now - this.move.lastTime) / 1000 * this.move.speed; // Slide\n\n    this.slideTo(this.dragging.init ? this.move.pos : this.round(this.move.pos)); // Normally, this is triggered in render(), but if there\n    // is nothing to render, we have to do it manually here.\n\n    if (!this.dragging.init && this.pos.cur === this.pos.dest) {\n      this.trigger('moveEnd');\n    } // Update times for future iteration\n\n\n    this.move.lastTime = this.move.now;\n  }\n  /**\n   * Stops continuous movement.\n   *\n   * @return {Void}\n   */\n\n\n  stop() {\n    if (this.dragging.source === 'button') {\n      this.dragging.init = 0;\n      this.dragging.released = 1;\n    }\n  }\n  /**\n   * Activate previous item.\n   *\n   * @return {Void}\n   */\n\n\n  prev() {\n    this.activate(this.rel.activeItem == null ? 0 : this.rel.activeItem - 1);\n  }\n  /**\n   * Activate next item.\n   *\n   * @return {Void}\n   */\n\n\n  next() {\n    this.activate(this.rel.activeItem == null ? 0 : this.rel.activeItem + 1);\n  }\n  /**\n   * Activate previous page.\n   *\n   * @return {Void}\n   */\n\n\n  prevPage() {\n    this.activatePage(this.rel.activePage - 1);\n  }\n  /**\n   * Activate next page.\n   *\n   * @return {Void}\n   */\n\n\n  nextPage() {\n    this.activatePage(this.rel.activePage + 1);\n  }\n\n  /**\n   * Slide SLIDEE by amount of pixels.\n   *\n   * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.\n   * @param {Bool} immediate Reposition immediately without an animation.\n   *\n   * @return {Void}\n   */\n  slideBy(delta, immediate = false) {\n    if (!delta) {\n      return;\n    }\n\n    if (this.itemNav) {\n      (this.centeredNav ? this.toCenter : this.toStart)(this.within((this.centeredNav ? this.rel.centerItem : this.rel.firstItem) + this.o.scrollBy * delta, 0, this.items.length));\n    } else {\n      this.slideTo(this.pos.dest + delta, immediate);\n    }\n  }\n\n  /**\n   * Animate SLIDEE to a specific position.\n   *\n   * @param {Int}  pos       New position.\n   * @param {Bool} immediate Reposition immediately without an animation.\n   *\n   * @return {Void}\n   */\n  slideTo(pos, immediate = false) {\n    this._slideTo(pos, immediate);\n  }\n  /**\n   * Core method for handling `toLocation` methods.\n   *\n   * @param  {String} location\n   * @param  {Mixed}  item\n   * @param  {Bool}   immediate\n   *\n   * @return {Void}\n   */\n\n\n  to(location, item, immediate) {\n    // Optional arguments logic\n    if (SlideBars.type(item) === 'boolean') {\n      immediate = item;\n      item = undefined;\n    }\n\n    if (item === undefined) {\n      this._slideTo(this.pos[location], immediate);\n    } else {\n      // You can't align items to sides of the frame\n      // when centered navigation type is enabled\n      if (this.centeredNav && location !== 'center') {\n        return;\n      }\n\n      var itemPos = this.getPos(item);\n\n      if (itemPos) {\n        this._slideTo(itemPos[location], immediate, !this.centeredNav);\n      }\n    }\n  }\n  /**\n   * Animate element or the whole SLIDEE to the start of the frame.\n   *\n   * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n   * @param {Bool}  immediate Reposition immediately without an animation.\n   *\n   * @return {Void}\n   */\n\n\n  toStart(item, immediate = false) {\n    this.to('start', item, immediate);\n  }\n  /**\n   * Animate element or the whole SLIDEE to the end of the frame.\n   *\n   * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n   * @param {Bool}  immediate Reposition immediately without an animation.\n   *\n   * @return {Void}\n   */\n\n\n  toEnd(item, immediate) {\n    this.to('end', item, immediate);\n  }\n  /**\n   * Animate element or the whole SLIDEE to the center of the frame.\n   *\n   * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n   * @param {Bool}  immediate Reposition immediately without an animation.\n   *\n   * @return {Void}\n   */\n\n\n  toCenter(item, immediate = false) {\n    this.to('center', item, immediate);\n  }\n  /**\n   * Get the index of an item in SLIDEE.\n   *\n   * @param {Mixed} item     Item DOM element.\n   *\n   * @return {Int}  Item index, or -1 if not found.\n   */\n\n\n  getIndex(item) {\n    return item != null ? this.isNumber(item) ? item >= 0 && item < this.items.length ? item : -1 : this.$items.index(item) : -1;\n  }\n  /**\n   * Get index of an item in SLIDEE based on a variety of input types.\n   *\n   * @param  {Mixed} item DOM element, positive or negative integer.\n   *\n   * @return {Int}   Item index, or -1 if not found.\n   */\n\n\n  getRelativeIndex(item) {\n    return this.getIndex(this.isNumber(item) && item < 0 ? item + this.items.length : item);\n  }\n  /**\n   * Activates an item.\n   *\n   * @param  {Mixed} item Item DOM element, or index starting at 0.\n   *\n   * @return {Mixed} Activated item index or false on fail.\n   */\n\n\n  _activate(item, force = undefined) {\n    var index = this.getIndex(item);\n\n    if (!this.itemNav || index < 0) {\n      return false;\n    } // Update classes, last active index, and trigger active event only when there\n    // has been a change. Otherwise just return the current active index.\n\n\n    if (this.last.active !== index || force) {\n      // Update classes\n      this.$items.eq(this.rel.activeItem).removeClass(this.o.activeClass);\n      this.$items.eq(index).addClass(this.o.activeClass);\n      this.last.active = this.rel.activeItem = index;\n      this.updateButtonsState();\n      this.trigger('active', index);\n    }\n\n    return index;\n  }\n  /**\n   * Activates an item and helps with further navigation when o.smart is enabled.\n   *\n   * @param {Mixed} item      Item DOM element, or index starting at 0.\n   * @param {Bool}  immediate Whether to reposition immediately in smart navigation.\n   *\n   * @return {Void}\n   */\n\n\n  activate(item, immediate = false) {\n    var index = this._activate(item); // Smart navigation\n\n\n    if (this.o.smart && index !== false) {\n      // When centeredNav is enabled, center the element.\n      // Otherwise, determine where to position the element based on its current position.\n      // If the element is currently on the far end side of the frame, assume that user is\n      // moving forward and animate it to the start of the visible frame, and vice versa.\n      if (this.centeredNav) {\n        this.toCenter(index, immediate);\n      } else if (index >= this.rel.lastItem) {\n        this.toStart(index, immediate);\n      } else if (index <= this.rel.firstItem) {\n        this.toEnd(index, immediate);\n      } else {\n        this.resetCycle();\n      }\n    }\n  }\n  /**\n   * Activates a page.\n   *\n   * @param {Int}  index     Page index, starting from 0.\n   * @param {Bool} immediate Whether to reposition immediately without animation.\n   *\n   * @return {Void}\n   */\n\n\n  activatePage(index, immediate = false) {\n    if (this.isNumber(index)) {\n      this.slideTo(this.pages[this.within(index, 0, this.pages.length - 1)], immediate);\n    }\n  }\n  /**\n   * Return relative positions of items based on their visibility within FRAME.\n   *\n   * @param {Int} slideePos Position of SLIDEE.\n   *\n   * @return {Void}\n   */\n\n\n  getRelatives(slideePos) {\n    slideePos = this.within(this.isNumber(slideePos) ? slideePos : this.pos.dest, this.pos.start, this.pos.end);\n    let relatives = {};\n    let centerOffset = this.forceCenteredNav ? 0 : this.frameSize / 2; // Determine active page\n\n    if (!this.parallax) {\n      for (let p = 0, pl = this.pages.length; p < pl; p++) {\n        if (slideePos >= this.pos.end || p === this.pages.length - 1) {\n          relatives.activePage = this.pages.length - 1;\n          break;\n        }\n\n        if (slideePos <= this.pages[p] + centerOffset) {\n          relatives.activePage = p;\n          break;\n        }\n      }\n    } // Relative item indexes\n\n\n    if (this.itemNav) {\n      let first = false;\n      let last = false;\n      let center = false; // From start\n\n      for (let i = 0, il = this.items.length; i < il; i++) {\n        // First item\n        if (first === false && slideePos <= this.items[i].start + this.items[i].half) {\n          first = i;\n        } // Center item\n\n\n        if (center === false && slideePos <= this.items[i].center + this.items[i].half) {\n          center = i;\n        } // Last item\n\n\n        if (i === il - 1 || slideePos <= this.items[i].end + this.items[i].half) {\n          last = i;\n          break;\n        }\n      } // Safe assignment, just to be sure the false won't be returned\n\n\n      relatives.firstItem = this.isNumber(first) ? first : 0;\n      relatives.centerItem = this.isNumber(center) ? center : relatives.firstItem;\n      relatives.lastItem = this.isNumber(last) ? last : relatives.centerItem;\n    }\n\n    return relatives;\n  }\n  /**\n   * Update object with relative positions.\n   *\n   * @param {Int} newPos\n   *\n   * @return {Void}\n   */\n\n\n  updateRelatives(newPos = undefined) {\n    $.extend(this.rel, this.getRelatives(newPos));\n  }\n  /**\n   * Disable navigation buttons when needed.\n   *\n   * Adds disabledClass, and when the button is <button> or <input>, activates :disabled state.\n   *\n   * @return {Void}\n   */\n\n\n  updateButtonsState() {\n    var isStart = this.pos.dest <= this.pos.start;\n    var isEnd = this.pos.dest >= this.pos.end;\n    var slideePosState = (isStart ? 1 : 0) | (isEnd ? 2 : 0); // Update paging buttons only if there has been a change in SLIDEE position\n\n    if (this.last.slideePosState !== slideePosState) {\n      this.last.slideePosState = slideePosState;\n\n      if (this.$prevPageButton.is('button,input')) {\n        this.$prevPageButton.prop('disabled', isStart);\n      }\n\n      if (this.$nextPageButton.is('button,input')) {\n        this.$nextPageButton.prop('disabled', isEnd);\n      }\n\n      this.$prevPageButton.add(this.$backwardButton)[isStart ? 'addClass' : 'removeClass'](this.o.disabledClass);\n      this.$nextPageButton.add(this.$forwardButton)[isEnd ? 'addClass' : 'removeClass'](this.o.disabledClass);\n    } // Forward & Backward buttons need a separate state caching because we cannot \"property disable\"\n    // them while they are being used, as disabled buttons stop emitting mouse events.\n\n\n    if (this.last.fwdbwdState !== slideePosState && this.dragging.released) {\n      this.last.fwdbwdState = slideePosState;\n\n      if (this.$backwardButton.is('button,input')) {\n        this.$backwardButton.prop('disabled', isStart);\n      }\n\n      if (this.$forwardButton.is('button,input')) {\n        this.$forwardButton.prop('disabled', isEnd);\n      }\n    } // Item navigation\n\n\n    if (this.itemNav && this.rel.activeItem != null) {\n      var isFirst = this.rel.activeItem === 0;\n      var isLast = this.rel.activeItem >= this.items.length - 1;\n      var itemsButtonState = (isFirst ? 1 : 0) | (isLast ? 2 : 0);\n\n      if (this.last.itemsButtonState !== itemsButtonState) {\n        this.last.itemsButtonState = itemsButtonState;\n\n        if (this.$prevButton.is('button,input')) {\n          this.$prevButton.prop('disabled', isFirst);\n        }\n\n        if (this.$nextButton.is('button,input')) {\n          this.$nextButton.prop('disabled', isLast);\n        }\n\n        this.$prevButton[isFirst ? 'addClass' : 'removeClass'](this.o.disabledClass);\n        this.$nextButton[isLast ? 'addClass' : 'removeClass'](this.o.disabledClass);\n      }\n    }\n  }\n  /**\n   * Resume cycling.\n   *\n   * @param {Int} priority Resume pause with priority lower or equal than this. Used internally for pauseOnHover.\n   *\n   * @return {Void}\n   */\n\n\n  resume(priority = -1) {\n    if (!this.o.cycleBy || !this.o.cycleInterval || this.o.cycleBy === 'items' && (!this.items[0] || this.rel.activeItem == null) || priority < this.isPaused) {\n      return;\n    }\n\n    this.isPaused = 0;\n\n    if (this.cycleID) {\n      this.cycleID = clearTimeout(this.cycleID);\n    } else {\n      this.trigger('resume');\n    }\n\n    this.cycleID = setTimeout(() => {\n      this.trigger('cycle');\n\n      switch (this.o.cycleBy) {\n        case 'items':\n          this.activate(this.rel.activeItem >= this.items.length - 1 ? 0 : this.rel.activeItem + 1);\n          break;\n\n        case 'pages':\n          this.activatePage(this.rel.activePage >= this.pages.length - 1 ? 0 : this.rel.activePage + 1);\n          break;\n      }\n    }, this.o.cycleInterval);\n  }\n  /**\n   * Pause cycling.\n   *\n   * @param {Int} priority Pause priority. 100 is default. Used internally for pauseOnHover.\n   *\n   * @return {Void}\n   */\n\n\n  pause(priority = -1) {\n    if (priority < this.isPaused) {\n      return;\n    }\n\n    this.isPaused = priority || 100;\n\n    if (this.cycleID) {\n      this.cycleID = clearTimeout(this.cycleID);\n      this.trigger('pause');\n    }\n  }\n  /**\n   * Toggle cycling.\n   *\n   * @return {Void}\n   */\n\n\n  toggle() {\n    this.cycleID ? this.pause() : this.resume();\n  }\n  /**\n   * Updates a signle or multiple option values.\n   *\n   * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.\n   * @param {Mixed} value New option value.\n   *\n   * @return {Void}\n   */\n\n\n  set(name, value) {\n    if ($.isPlainObject(name)) {\n      $.extend(this.o, name);\n    } else if (this.o.hasOwnProperty(name)) {\n      this.o[name] = value;\n    }\n  }\n  /**\n   * Add one or multiple items to the SLIDEE end, or a specified position index.\n   *\n   * @param {Mixed} element Node element, or HTML string.\n   * @param {Int}   index   Index of a new item position. By default item is appended at the end.\n   *\n   * @return {Void}\n   */\n\n\n  add(element, index) {\n    var $element = $(element);\n\n    if (this.itemNav) {\n      // Insert the element(s)\n      if (index == null || !this.items[0] || index >= this.items.length) {\n        $element.appendTo(this.$slidee);\n      } else if (this.items.length) {\n        $element.insertBefore(this.items[index].el);\n      } // Adjust the activeItem index\n\n\n      if (this.rel.activeItem != null && index <= this.rel.activeItem) {\n        this.last.active = this.rel.activeItem += $element.length;\n      }\n    } else {\n      this.$slidee.append($element);\n    } // Reload\n\n\n    this.load();\n  }\n\n  /**\n   * Remove an item from SLIDEE.\n   *\n   * @param {Mixed} element Item index, or DOM element.\n   * @param {Int}   index   Index of a new item position. By default item is appended at the end.\n   *\n   * @return {Void}\n   */\n  remove(element) {\n    if (this.itemNav) {\n      var index = this.getRelativeIndex(element);\n\n      if (index > -1) {\n        // Remove the element\n        this.$items.eq(index).remove(); // If the current item is being removed, activate new one after reload\n\n        var reactivate = index === this.rel.activeItem; // Adjust the activeItem index\n\n        if (this.rel.activeItem != null && index < this.rel.activeItem) {\n          this.last.active = --this.rel.activeItem;\n        } // Reload\n\n\n        this.load(); // Activate new item at the removed position\n\n        if (reactivate) {\n          this.last.active = null;\n          this.activate(this.rel.activeItem);\n        }\n      }\n    } else {\n      $(element).remove();\n      this.load();\n    }\n  }\n\n  /**\n   * Helps re-arranging items.\n   *\n   * @param  {Mixed} item     Item DOM element, or index starting at 0. Use negative numbers to select items from the end.\n   * @param  {Mixed} position Item insertion anchor. Accepts same input types as item argument.\n   * @param  {Bool}  after    Insert after instead of before the anchor.\n   *\n   * @return {Void}\n   */\n  moveItem(item, position, after = false) {\n    item = this.getRelativeIndex(item);\n    position = this.getRelativeIndex(position); // Move only if there is an actual change requested\n\n    if (item > -1 && position > -1 && item !== position && (!after || position !== item - 1) && (after || position !== item + 1)) {\n      this.$items.eq(item)[after ? 'insertAfter' : 'insertBefore'](this.items[position].el);\n      var shiftStart = item < position ? item : after ? position : position - 1;\n      var shiftEnd = item > position ? item : after ? position + 1 : position;\n      var shiftsUp = item > position; // Update activeItem index\n\n      if (this.rel.activeItem != null) {\n        if (item === this.rel.activeItem) {\n          this.last.active = this.rel.activeItem = after ? shiftsUp ? position + 1 : position : shiftsUp ? position : position - 1;\n        } else if (this.rel.activeItem > shiftStart && this.rel.activeItem < shiftEnd) {\n          this.last.active = this.rel.activeItem += shiftsUp ? 1 : -1;\n        }\n      } // Reload\n\n\n      this.load();\n    }\n  }\n  /**\n   * Move item after the target anchor.\n   *\n   * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.\n   * @param  {Mixed} position Target position anchor. Can be DOM element or item index.\n   *\n   * @return {Void}\n   */\n\n\n  moveAfter(item, position) {\n    this.moveItem(item, position, true);\n  }\n  /**\n   * Move item before the target anchor.\n   *\n   * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.\n   * @param  {Mixed} position Target position anchor. Can be DOM element or item index.\n   *\n   * @return {Void}\n   */\n\n\n  moveBefore(item, position) {\n    this.moveItem(item, position);\n  }\n\n  /**\n   * Registers callbacks.\n   *\n   * @param  {Mixed} name  Event name, or callbacks map.\n   * @param  {Mixed} fn    Callback, or an array of callback functions.\n   *\n   * @return {Void}\n   */\n  on(name, fn = undefined) {\n    // Callbacks map\n    if (SlideBars.type(name) === 'object') {\n      for (var key in name) {\n        if (name.hasOwnProperty(key)) {\n          this.on(key, name[key]);\n        }\n      } // Callback\n\n    } else if (SlideBars.type(fn) === 'function') {\n      var names = name.split(' ');\n\n      for (var n = 0, nl = names.length; n < nl; n++) {\n        this.callbacks[names[n]] = this.callbacks[names[n]] || [];\n\n        if (this.callbackIndex(names[n], fn) === -1) {\n          this.callbacks[names[n]].push(fn);\n        }\n      } // Callbacks array\n\n    } else if (SlideBars.type(fn) === 'array') {\n      for (var f = 0, fl = fn.length; f < fl; f++) {\n        this.on(name, fn[f]);\n      }\n    }\n  }\n  /**\n   * Registers callbacks to be executed only once.\n   *\n   * @param  {Mixed} name  Event name, or callbacks map.\n   * @param  {Mixed} fn    Callback, or an array of callback functions.\n   *\n   * @return {Void}\n   */\n\n\n  one(name, fn) {\n    var self = this;\n\n    function proxy() {\n      fn.apply(self, arguments);\n      self.off(name, proxy);\n    }\n\n    this.on(name, proxy);\n  }\n  /**\n   * Remove one or all callbacks.\n   *\n   * @param  {String} name Event name.\n   * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.\n   *\n   * @return {Void}\n   */\n\n\n  off(name, fn) {\n    if (fn instanceof Array) {\n      for (var f = 0, fl = fn.length; f < fl; f++) {\n        this.off(name, fn[f]);\n      }\n    } else {\n      var names = name.split(' ');\n\n      for (var n = 0, nl = names.length; n < nl; n++) {\n        this.callbacks[names[n]] = this.callbacks[names[n]] || [];\n\n        if (fn == null) {\n          this.callbacks[names[n]].length = 0;\n        } else {\n          var index = this.callbackIndex(names[n], fn);\n\n          if (index !== -1) {\n            this.callbacks[names[n]].splice(index, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns callback array index.\n   *\n   * @param  {String}   name Event name.\n   * @param  {Function} fn   Function\n   *\n   * @return {Int} Callback array index, or -1 if isn't registered.\n   */\n  callbackIndex(name, fn) {\n    for (var i = 0, l = this.callbacks[name].length; i < l; i++) {\n      if (this.callbacks[name][i] === fn) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Reset next cycle timeout.\n   *\n   * @return {Void}\n   */\n\n\n  resetCycle() {\n    if (this.dragging.released && !this.isPaused) {\n      this.resume();\n    }\n  }\n  /**\n   * Calculate SLIDEE representation of handle position.\n   *\n   * @param  {Int} handlePos\n   *\n   * @return {Int}\n   */\n\n\n  handleToSlidee(handlePos) {\n    return this.round(this.within(handlePos, this.hPos.start, this.hPos.end) / this.hPos.end * (this.pos.end - this.pos.start)) + this.pos.start;\n  }\n  /**\n   * Keeps track of a dragging delta history.\n   *\n   * @return {Void}\n   */\n\n\n  draggingHistoryTick() {\n    // Looking at this, I know what you're thinking :) But as we need only 4 history states, doing it this way\n    // as opposed to a proper loop is ~25 bytes smaller (when minified with GCC), a lot faster, and doesn't\n    // generate garbage. The loop version would create 2 new variables on every tick. Unexaptable!\n    this.dragging.history[0] = this.dragging.history[1];\n    this.dragging.history[1] = this.dragging.history[2];\n    this.dragging.history[2] = this.dragging.history[3];\n    this.dragging.history[3] = this.dragging.delta;\n  }\n  /**\n   * Initialize continuous movement.\n   *\n   * @return {Void}\n   */\n\n\n  continuousInit(source) {\n    this.dragging.released = 0;\n    this.dragging.source = source;\n    this.dragging.slidee = source === 'slidee';\n  }\n  /**\n   * Dragging initiator.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  dragInit(event) {\n    var isTouch = event.type === 'touchstart';\n    var source = event.data.source;\n    var isSlidee = source === 'slidee'; // Ignore when already in progress, or interactive element in non-touch navivagion\n\n    if (this.dragging.init || !isTouch && this.isInteractive(event.target)) {\n      return;\n    } // Handle dragging conditions\n\n\n    if (source === 'handle' && (!this.o.dragHandle || this.hPos.start === this.hPos.end)) {\n      return;\n    } // SLIDEE dragging conditions\n\n\n    if (isSlidee && !(isTouch ? this.o.touchDragging : this.o.mouseDragging && event.which < 2)) {\n      return;\n    }\n\n    if (!isTouch) {\n      // prevents native image dragging in Firefox\n      this.stopDefault(event);\n    } // Reset dragging object\n\n\n    this.continuousInit(source); // Properties used in dragHandler\n\n    this.dragging.init = 0;\n    this.dragging.$source = $(event.target);\n    this.dragging.touch = isTouch;\n    this.dragging.pointer = isTouch ? event.originalEvent.touches[0] : event;\n    this.dragging.initX = this.dragging.pointer.pageX;\n    this.dragging.initY = this.dragging.pointer.pageY;\n    this.dragging.initPos = isSlidee ? this.pos.cur : this.hPos.cur;\n    this.dragging.start = +new Date();\n    this.dragging.time = 0;\n    this.dragging.path = 0;\n    this.dragging.delta = 0;\n    this.dragging.locked = 0;\n    this.dragging.history = [0, 0, 0, 0];\n    this.dragging.pathToLock = isSlidee ? isTouch ? 30 : 10 : 0; // Bind dragging events\n\n    this.$doc.on(isTouch ? this.dragTouchEvents : this.dragMouseEvents, this.dragHandler); // Pause ongoing cycle\n\n    this.pause(1); // Add dragging class\n\n    (isSlidee ? this.$slidee : this.$handle).addClass(this.o.draggedClass); // Trigger moveStart event\n\n    this.trigger('moveStart'); // Keep track of a dragging path history. This is later used in the\n    // dragging release swing calculation when dragging SLIDEE.\n\n    if (isSlidee) {\n      this.historyID = setInterval(this.draggingHistoryTick.bind(this), 10);\n    }\n  }\n  /**\n   * Handler for dragging scrollbar handle or SLIDEE.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  dragHandler(event) {\n    this.dragging.released = event.type === 'mouseup' || event.type === 'touchend';\n    this.dragging.pointer = this.dragging.touch ? event.originalEvent[this.dragging.released ? 'changedTouches' : 'touches'][0] : event;\n    this.dragging.pathX = this.dragging.pointer.pageX - this.dragging.initX;\n    this.dragging.pathY = this.dragging.pointer.pageY - this.dragging.initY;\n    this.dragging.path = this.sqrt(this.pow(this.dragging.pathX, 2) + this.pow(this.dragging.pathY, 2));\n    this.dragging.delta = this.o.horizontal ? this.dragging.pathX : this.dragging.pathY;\n    if (!this.dragging.released && this.dragging.path < 1) return; // We haven't decided whether this is a drag or not...\n\n    if (!this.dragging.init) {\n      // If the drag path was very short, maybe it's not a drag?\n      if (this.dragging.path < this.o.dragThreshold) {\n        // If the pointer was released, the path will not become longer and it's\n        // definitely not a drag. If not released yet, decide on next iteration\n        return this.dragging.released ? this.dragEnd() : undefined;\n      } else {\n        // If dragging path is sufficiently long we can confidently start a drag\n        // if drag is in different direction than scroll, ignore it\n        if (this.o.horizontal ? this.abs(this.dragging.pathX) > this.abs(this.dragging.pathY) : this.abs(this.dragging.pathX) < this.abs(this.dragging.pathY)) {\n          this.dragging.init = 1;\n        } else {\n          return this.dragEnd();\n        }\n      }\n    }\n\n    this.stopDefault(event); // Disable click on a source element, as it is unwelcome when dragging\n\n    if (!this.dragging.locked && this.dragging.path > this.dragging.pathToLock && this.dragging.slidee) {\n      this.dragging.locked = 1;\n      this.dragging.$source.on(this.clickEvent, this.disableOneEvent);\n    } // Cancel dragging on release\n\n\n    if (this.dragging.released) {\n      this.dragEnd(); // Adjust path with a swing on mouse release\n\n      if (this.o.releaseSwing && this.dragging.slidee) {\n        this.dragging.swing = (this.dragging.delta - this.dragging.history[0]) / 40 * 300;\n        this.dragging.delta += this.dragging.swing;\n        this.dragging.tweese = this.abs(this.dragging.swing) > 10;\n      }\n    }\n\n    this._slideTo(this.dragging.slidee ? this.round(this.dragging.initPos - this.dragging.delta) : this.handleToSlidee(this.dragging.initPos + this.dragging.delta));\n  }\n  /**\n   * Stops dragging and cleans up after it.\n   *\n   * @return {Void}\n   */\n\n\n  dragEnd() {\n    clearInterval(this.historyID);\n    this.dragging.released = true;\n    this.$doc.off(this.dragging.touch ? this.dragTouchEvents : this.dragMouseEvents, this.dragHandler);\n    (this.dragging.slidee ? this.$slidee : this.$handle).removeClass(this.o.draggedClass); // Make sure that disableOneEvent is not active in next tick.\n\n    setTimeout(() => {\n      this.dragging.$source.off(this.clickEvent, this.disableOneEvent);\n    }); // Normally, this is triggered in render(), but if there\n    // is nothing to render, we have to do it manually here.\n\n    if (this.pos.cur === this.pos.dest && this.dragging.init) {\n      this.trigger('moveEnd');\n    } // Resume ongoing cycle\n\n\n    this.resume(1);\n    this.dragging.init = 0;\n  }\n  /**\n   * Check whether element is interactive.\n   *\n   * @return {Boolean}\n   */\n\n\n  isInteractive(element) {\n    return ~$.inArray(element.nodeName, this.interactiveElements) || $(element).is(this.o.interactive);\n  }\n  /**\n   * Continuous movement cleanup on mouseup.\n   *\n   * @return {Void}\n   */\n\n\n  movementReleaseHandler() {\n    this.stop();\n    this.$doc.off('mouseup', this.movementReleaseHandler);\n  }\n  /**\n   * Buttons navigation handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  buttonsHandler(event) {\n    /*jshint validthis:true */\n    this.stopDefault(event);\n\n    switch (this) {\n      case this.$forwardButton[0]:\n      case this.$backwardButton[0]:\n        this.moveBy(this.$forwardButton.is(this) ? this.o.moveBy : -this.o.moveBy);\n        this.$doc.on('mouseup', this.movementReleaseHandler);\n        break;\n\n      case this.$prevButton[0]:\n        this.prev();\n        break;\n\n      case this.$nextButton[0]:\n        this.next();\n        break;\n\n      case this.$prevPageButton[0]:\n        this.prevPage();\n        break;\n\n      case this.$nextPageButton[0]:\n        this.nextPage();\n        break;\n    }\n  }\n  /**\n   * Mouse wheel delta normalization.\n   *\n   * @param  {Event} event\n   *\n   * @return {Int}\n   */\n\n\n  normalizeWheelDelta(event) {\n    // wheelDelta needed only for IE8-\n    this.scrolling.curDelta = (this.o.horizontal ? event.deltaY || event.deltaX : event.deltaY) || -event.wheelDelta;\n    this.scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;\n\n    if (!this.itemNav) {\n      return this.scrolling.curDelta;\n    }\n\n    this.time = +new Date();\n\n    if (this.scrolling.last < this.time - this.scrolling.resetTime) {\n      this.scrolling.delta = 0;\n    }\n\n    this.scrolling.last = this.time;\n    this.scrolling.delta += this.scrolling.curDelta;\n\n    if (this.abs(this.scrolling.delta) < 1) {\n      this.scrolling.finalDelta = 0;\n    } else {\n      this.scrolling.finalDelta = this.round(this.scrolling.delta / 1);\n      this.scrolling.delta %= 1;\n    }\n\n    return this.scrolling.finalDelta;\n  }\n  /**\n   * Mouse scrolling handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  scrollHandler(event) {\n    console.log('scrollHandler', event); // Mark event as originating in a Sly instance\n\n    event.originalEvent[this.namespace] = this; // Don't hijack global scrolling\n\n    var time = +new Date();\n\n    if (this.lastGlobalWheel + this.o.scrollHijack > time && this.$scrollSource[0] !== document && this.$scrollSource[0] !== window) {\n      this.lastGlobalWheel = time;\n      return;\n    } // Ignore if there is no scrolling to be done\n\n\n    if (!this.o.scrollBy || this.pos.start === this.pos.end) {\n      return;\n    }\n\n    var delta = this.normalizeWheelDelta(event.originalEvent); // Trap scrolling only when necessary and/or requested\n\n    if (this.o.scrollTrap || delta > 0 && this.pos.dest < this.pos.end || delta < 0 && this.pos.dest > this.pos.start) {\n      this.stopDefault(event, true);\n    }\n\n    this.slideBy(this.o.scrollBy * delta);\n  }\n  /**\n   * Scrollbar click handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  scrollbarHandler(event) {\n    console.log('scrollbarHandler', event); // Only clicks on scroll bar. Ignore the handle.\n\n    if (this.o.clickBar && event.target === this.$sb[0]) {\n      this.stopDefault(event); // Calculate new handle position and sync SLIDEE to it\n\n      this.slideTo(this.handleToSlidee((this.o.horizontal ? event.pageX - this.$sb.offset().left : event.pageY - this.$sb.offset().top) - this.handleSize / 2));\n    }\n  }\n  /**\n   * Keyboard input handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  keyboardHandler(event) {\n    if (!this.o.keyboardNavBy) {\n      return;\n    }\n\n    switch (event.which) {\n      // Left or Up\n      case this.o.horizontal ? 37 : 38:\n        this.stopDefault(event);\n        this[this.o.keyboardNavBy === 'pages' ? 'prevPage' : 'prev']();\n        break;\n      // Right or Down\n\n      case this.o.horizontal ? 39 : 40:\n        this.stopDefault(event);\n        this[this.o.keyboardNavBy === 'pages' ? 'nextPage' : 'next']();\n        break;\n    }\n  }\n  /**\n   * Click on item activation handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  activateHandler(event) {\n    /*jshint validthis:true */\n    let target = event.currentTarget; // Ignore clicks on interactive elements.\n\n    if (this.isInteractive(target)) {\n      event.originalEvent[this.namespace + 'ignore'] = true;\n      return;\n    } // Ignore events that:\n    // - are not originating from direct SLIDEE children\n    // - originated from interactive elements\n\n\n    if (target.parentNode !== this.$slidee[0] || event.originalEvent[this.namespace + 'ignore']) return;\n    this.activate(target);\n  }\n  /**\n   * Click on page button handler.\n   *\n   * @param {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  activatePageHandler() {\n    /*jshint validthis:true */\n    // Accept only events from direct pages bar children.\n    if (this.parentNode === this.$pb[0]) {\n      this.activatePage(this.$pages.index(this));\n    }\n  }\n  /**\n   * Pause on hover handler.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  pauseOnHoverHandler(event) {\n    if (this.o.pauseOnHover) {\n      this[event.type === 'mouseenter' ? 'pause' : 'resume'](2);\n    }\n  }\n  /**\n   * Trigger callbacks for event.\n   *\n   * @param  {String} name Event name.\n   * @param  {Mixed}  argX Arguments passed to callbacks.\n   *\n   * @return {Void}\n   */\n\n\n  trigger(name, arg1 = undefined) {\n    if (this.callbacks[name]) {\n      this.l = this.callbacks[name].length; // Callbacks will be stored and executed from a temporary array to not\n      // break the execution queue when one of the callbacks unbinds itself.\n\n      this.tmpArray.length = 0;\n\n      for (this.i = 0; this.i < this.l; this.i++) {\n        this.tmpArray.push(this.callbacks[name][this.i]);\n      } // Execute the callbacks\n\n\n      for (this.i = 0; this.i < this.l; this.i++) {\n        this.tmpArray[this.i].call(this, name, arg1);\n      }\n    }\n  }\n  /**\n  * Destroys instance and everything it created.\n  *\n  * @return {Void}\n  */\n\n\n  destroy() {\n    // Remove the reference to itself\n    SlideBars.removeInstance(this.frame, this.namespace); // Unbind all events\n\n    this.$scrollSource.add(this.$handle).add(this.$sb).add(this.$pb).add(this.$forwardButton).add(this.$backwardButton).add(this.$prevButton).add(this.$nextButton).add(this.$prevPageButton).add(this.$nextPageButton).off('.' + this.namespace); // Unbinding specifically as to not nuke out other instances\n\n    this.$doc.off('keydown', this.keyboardHandler); // Remove classes\n\n    this.$prevButton.add(this.$nextButton).add(this.$prevPageButton).add(this.$nextPageButton).removeClass(this.o.disabledClass);\n\n    if (this.$items && this.rel.activeItem != null) {\n      this.$items.eq(this.rel.activeItem).removeClass(this.o.activeClass);\n    } // Remove page items\n\n\n    this.$pb.empty();\n\n    if (!this.parallax) {\n      // Unbind events from frame\n      this.$frame.off('.' + this.namespace); // Restore original styles\n\n      this.frameStyles.restore();\n      this.slideeStyles.restore();\n      this.sbStyles.restore();\n      this.handleStyles.restore(); // Remove the instance from element data storage\n\n      $.removeData(this.frame, this.namespace);\n    } // Clean up collections\n\n\n    this.items.length = this.pages.length = 0;\n    this.last = {}; // Reset initialized status and return the instance\n\n    this.initialized = 0;\n    return this;\n  }\n  /**\n   * Initialize.\n   *\n   * @return {Object}\n   */\n\n\n  init() {\n    if (this.initialized) {\n      return;\n    } // Disallow multiple instances on the same element\n\n\n    if (SlideBars.getInstance(this.frame, this.namespace)) throw new Error('There is already a Sly instance on this element'); // Store the reference to itself\n\n    SlideBars.storeInstance(this.frame, this.namespace, this); // Register callbacks map\n\n    this.on(this.callbackMap); // Save styles\n\n    let holderProps = ['overflow', 'position'];\n    let movableProps = ['position', 'webkitTransform', 'msTransform', 'transform', 'left', 'top', 'width', 'height'];\n    this.frameStyles.save.apply(this.frameStyles, holderProps);\n    this.sbStyles.save.apply(this.sbStyles, holderProps);\n    this.slideeStyles.save.apply(this.slideeStyles, movableProps);\n    this.handleStyles.save.apply(this.handleStyles, movableProps); // Set required styles\n\n    var $movables = this.$handle;\n\n    if (!this.parallax) {\n      $movables = $movables.add(this.$slidee);\n      this.$frame.css('overflow', 'hidden');\n\n      if (!this.transform && this.$frame.css('position') === 'static') {\n        this.$frame.css('position', 'relative');\n      }\n    }\n\n    if (this.transform) {\n      if (this.gpuAcceleration) {\n        $movables.css(this.transform, this.gpuAcceleration);\n      }\n    } else {\n      if (this.$sb.css('position') === 'static') {\n        this.$sb.css('position', 'relative');\n      }\n\n      $movables.css({\n        position: 'absolute'\n      });\n    }\n\n    this.dragHandler = this.dragHandler.bind(this);\n    this.dragInit = this.dragInit.bind(this); // Navigation buttons\n\n    if (this.o.forward) {\n      this.$forwardButton.on(this.mouseDownEvent, this.buttonsHandler);\n    }\n\n    if (this.o.backward) {\n      this.$backwardButton.on(this.mouseDownEvent, this.buttonsHandler);\n    }\n\n    if (this.o.prev) {\n      this.$prevButton.on(this.clickEvent, this.buttonsHandler);\n    }\n\n    if (this.o.next) {\n      this.$nextButton.on(this.clickEvent, this.buttonsHandler);\n    }\n\n    if (this.o.prevPage) {\n      this.$prevPageButton.on(this.clickEvent, this.buttonsHandler);\n    }\n\n    if (this.o.nextPage) {\n      this.$nextPageButton.on(this.clickEvent, this.buttonsHandler);\n    } // Scrolling navigation\n\n\n    this.$scrollSource.on(this.wheelEvent, this.scrollHandler); // Clicking on scrollbar navigation\n\n    if (this.$sb[0]) {\n      this.$sb.on(this.clickEvent, this.scrollbarHandler);\n    } // Click on items navigation\n\n\n    if (this.itemNav && this.o.activateOn) {\n      this.$frame.on(this.o.activateOn + '.' + this.namespace, '*', this.activateHandler.bind(this));\n    } // Pages navigation\n\n\n    if (this.$pb[0] && this.o.activatePageOn) {\n      this.$pb.on(this.o.activatePageOn + '.' + this.namespace, '*', this.activatePageHandler.bind(this));\n    } // Dragging navigation\n\n\n    this.$dragSource.on(this.dragInitEvents, {\n      source: 'slidee'\n    }, this.dragInit); // Scrollbar dragging navigation\n\n    if (this.$handle) {\n      this.$handle.on(this.dragInitEvents, {\n        source: 'handle'\n      }, this.dragInit);\n    } // Keyboard navigation\n\n\n    this.$doc.on('keydown', this.keyboardHandler.bind(this));\n\n    if (!this.parallax) {\n      // Pause on hover\n      this.$frame.on('mouseenter.' + this.namespace + ' mouseleave.' + this.namespace, this.pauseOnHoverHandler.bind(this)); // Reset native FRAME element scroll\n\n      this.$frame.on('scroll.' + this.namespace, this.resetScroll);\n    } // Mark instance as initialized\n\n\n    this.initialized = 1; // Load\n\n    this.load(true); // Initiate automatic cycling\n\n    if (this.o.cycleBy && !this.parallax) {\n      this.o.startPaused ? this.pause() : this.resume();\n    } // Return instance\n\n\n    return this;\n  }\n  /**\n  * Return type of the value.\n  *\n  * @param  {Mixed} value\n  *\n  * @return {String}\n  */\n\n\n  static type(value) {\n    if (value == null) {\n      return String(value);\n    }\n\n    if (typeof value === 'object' || typeof value === 'function') {\n      return (Object.prototype.toString.call(value).match(/\\s([a-z]+)/i) || [])[1].toLowerCase() || 'object';\n    }\n\n    return typeof value;\n  }\n  /**\n   * Event preventDefault & stopPropagation helper.\n   *\n   * @param {Event} event     Event object.\n   * @param {Bool}  noBubbles Cancel event bubbling.\n   *\n   * @return {Void}\n   */\n\n\n  stopDefault(event, noBubbles = false) {\n    event.preventDefault();\n\n    if (noBubbles) {\n      event.stopPropagation();\n    }\n  }\n  /**\n   * Disables an event it was triggered on and unbinds itself.\n   *\n   * @param  {Event} event\n   *\n   * @return {Void}\n   */\n\n\n  disableOneEvent(event) {\n    /*jshint validthis:true */\n    this.stopDefault(event, true);\n    $(this).off(event.type, this.disableOneEvent);\n  }\n  /**\n   * Resets native element scroll values to 0.\n   *\n   * @return {Void}\n   */\n\n\n  resetScroll(event) {\n    /*jshint validthis:true */\n    event.target.scrollLeft = 0;\n    event.target.scrollTop = 0;\n  }\n  /**\n   * Check if variable is a number.\n   *\n   * @param {Mixed} value\n   *\n   * @return {Boolean}\n   */\n\n\n  isNumber(value) {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n  }\n  /**\n   * Parse style to pixels.\n   *\n   * @param {Object}   $item    jQuery object with element.\n   * @param {Property} property CSS property to get the pixels from.\n   *\n   * @return {Int}\n   */\n\n\n  getPx($item, property) {\n    return 0 | this.round(parseFloat(String($item.css(property)).replace(/[^\\-0-9.]/g, '')));\n  }\n  /**\n   * Make sure that number is within the limits.\n   *\n   * @param {Number} number\n   * @param {Number} min\n   * @param {Number} max\n   *\n   * @return {Number}\n   */\n\n\n  within(number, min, max) {\n    return number < min ? min : number > max ? max : number;\n  }\n\n  static getInstance(element, namespace) {\n    return $.data(element, namespace);\n  }\n\n  static removeInstance(element, namespace) {\n    return $.removeData(element, namespace);\n  }\n\n}\n\nSlideBars.storeInstance = function (element, namespace, sly) {\n  return $.data(element, namespace, sly);\n};\n/**\n * Saves element styles for later restoration.\n *\n * Example:\n *   var styles = new StyleRestorer(frame);\n *   styles.save('position');\n *   element.style.position = 'absolute';\n *   styles.restore(); // restores to state before the assignment above\n *\n * @param {Element} element\n */\n\n\nclass StyleRestorer {\n  constructor(element) {\n    this.style = {};\n    this.element = element;\n  }\n\n  save(...args) {\n    if (!this.element || !this.element.nodeType) return;\n\n    for (var i = 0; i < args.length; i++) {\n      let cssName = args[i];\n      this.style[cssName] = this.element.style[cssName];\n    }\n\n    return this;\n  }\n\n  restore() {\n    if (!this.element || !this.element.nodeType) return;\n\n    for (var prop in this.style) {\n      if (this.style.hasOwnProperty(prop)) this.element.style[prop] = this.style[prop];\n    }\n\n    return this;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/SlideBars.ts?");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jquery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;\n\n//# sourceURL=webpack:///external_%22jquery%22?");

/***/ }),

/***/ "jquery.easing":
/*!********************************!*\
  !*** external "jquery.easing" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_jquery_easing__;\n\n//# sourceURL=webpack:///external_%22jquery.easing%22?");

/***/ })

/******/ });
});